<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
<title>Tilt Test v17 - Trig</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { background: #050b14; overflow: hidden; touch-action: none; font-family: monospace; color: #4fc3f7; }
#gameCanvas { display: block; background: radial-gradient(circle, #0a1628 0%, #050b14 100%); }
#startBtn {
    position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
    padding: 20px 40px; font-size: 20px; background: #00E676; color: #050b14;
    border: none; border-radius: 12px; cursor: pointer; z-index: 100; font-weight: bold;
}
#info { position: absolute; top: 16px; left: 16px; font-size: 12px; pointer-events: none; }
#version { position: absolute; bottom: 16px; right: 16px; font-size: 12px; color: rgba(255,255,255,0.3); }
#warning { 
    position: absolute; top: 70%; left: 50%; transform: translate(-50%, -50%);
    color: #ff5252; font-weight: bold; display: none; text-align: center; width: 80%;
}
</style>
</head>
<body>
<canvas id="gameCanvas"></canvas>
<div id="info">Pitch: <span id="curPitch">0</span>°<br>Target Range: ±30°</div>
<div id="warning">PHONE TOO STEEP!<br>Tilt screen toward your face to calibrate.</div>
<div id="version">v17.0 (Trig / 30° Range)</div>
<button id="startBtn">CALIBRATE & START</button>

<script>
const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d");
const startBtn = document.getElementById("startBtn");
const warningEl = document.getElementById("warning");

let gameRunning = false;
let touchL = false, touchR = false;

// Physics Multipliers
const CONFIG = {
    rotTorque: 0.002,
    rotFriction: 0.97,
    driftSens: 2.5,        // Adjusted for Trig output
    driftFriction: 0.95,
    maxTiltRange: 30 * (Math.PI / 180), // 30 degrees in Radians
    wingWidth: 100,
    noseLength: 50
};

// State
let ship = { x: 0, y: 0, vx: 0, vy: 0, angle: -Math.PI / 2, vAngle: 0 };
let basePitch = 0; // Calibration zero point
let currentPitch = 0;
let currentRoll = 0;

function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
}
window.addEventListener("resize", resize);
resize();

function updateTouches(e) {
    if (!gameRunning) return;
    touchL = false; touchR = false;
    for (let i = 0; i < e.touches.length; i++) {
        if (e.touches[i].clientX < window.innerWidth / 2) touchL = true;
        else touchR = true;
    }
}
window.addEventListener("touchstart", updateTouches);
window.addEventListener("touchend", updateTouches);

function handleMotion(e) {
    const acc = e.accelerationIncludingGravity;
    if (!acc) return;

    // 1. Extract Pitch (Angle of phone face relative to ground)
    // We use Y and Z to determine the forward/backward tilt
    currentPitch = Math.atan2(acc.y, acc.z);
    
    // 2. Extract Roll (Side to side tilt)
    currentRoll = acc.x / 9.8; // Simple linear is fine for roll

    document.getElementById("curPitch").innerText = Math.round(currentPitch * (180/Math.PI));
}

function update() {
    if (!gameRunning) return;

    // --- ROTATION ---
    if (touchL) ship.vAngle -= CONFIG.rotTorque;
    if (touchR) ship.vAngle += CONFIG.rotTorque;
    ship.angle += ship.vAngle;
    ship.vAngle *= CONFIG.rotFriction;

    // --- TRANSLATION (The Trig Solution) ---
    // Calculate how far we are from calibration point
    let pitchDelta = currentPitch - basePitch;
    
    // Normalize and Clamp to the 30 degree range
    // This turns a -30 to +30 degree movement into a -1.0 to +1.0 force
    let forceY = Math.max(-1, Math.min(1, pitchDelta / CONFIG.maxTiltRange));
    let forceX = Math.max(-1, Math.min(1, currentRoll)); // Roll is usually simpler

    ship.vx += forceX * CONFIG.driftSens;
    ship.vy += forceY * CONFIG.driftSens;
    
    ship.x += ship.vx;
    ship.y += ship.vy;
    
    ship.vx *= CONFIG.driftFriction;
    ship.vy *= CONFIG.driftFriction;

    // --- WRAP ---
    if (ship.x < 0) ship.x = canvas.width;
    else if (ship.x > canvas.width) ship.x = 0;
    if (ship.y < 0) ship.y = canvas.height;
    else if (ship.y > canvas.height) ship.y = 0;
}

function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    if (!gameRunning) return;

    const hw = CONFIG.wingWidth / 2;
    const lX = ship.x + Math.cos(ship.angle - Math.PI/2) * hw;
    const lY = ship.y + Math.sin(ship.angle - Math.PI/2) * hw;
    const rX = ship.x + Math.cos(ship.angle + Math.PI/2) * hw;
    const rY = ship.y + Math.sin(ship.angle + Math.PI/2) * hw;
    const nX = ship.x + Math.cos(ship.angle) * CONFIG.noseLength;
    const nY = ship.y + Math.sin(ship.angle) * CONFIG.noseLength;

    ctx.fillStyle = "rgba(0, 230, 118, 0.2)";
    ctx.strokeStyle = "#00E676";
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.moveTo(lX, lY); ctx.lineTo(rX, rY); ctx.lineTo(nX, nY);
    ctx.closePath();
    ctx.fill(); ctx.stroke();

    // Engine Glow
    if (touchL) drawGlow(lX, lY);
    if (touchR) drawGlow(rX, rY);
}

function drawGlow(x, y) {
    ctx.save();
    ctx.shadowBlur = 15;
    ctx.shadowColor = "#FFF";
    ctx.fillStyle = "#FFF";
    ctx.beginPath(); ctx.arc(x, y, 8, 0, Math.PI*2); ctx.fill();
    ctx.restore();
}

function loop() { update(); draw(); requestAnimationFrame(loop); }
loop();

async function startGame() {
    if (typeof DeviceMotionEvent.requestPermission === 'function') {
        const res = await DeviceMotionEvent.requestPermission();
        if (res !== 'granted') return;
    }

    // Continuous monitoring for calibration check
    window.addEventListener("devicemotion", handleMotion);

    startBtn.addEventListener("click", () => {
        // Safety Check: If angle is > 80 degrees, it's too steep
        const pitchDegrees = currentPitch * (180/Math.PI);
        if (Math.abs(pitchDegrees) > 80) {
            warningEl.style.display = "block";
            return;
        }

        warningEl.style.display = "none";
        basePitch = currentPitch; // Set the Zero Point
        gameRunning = true;
        startBtn.style.display = "none";
        ship.x = canvas.width / 2;
        ship.y = canvas.height / 2;
    });
}
startGame();
</script>
</body>
</html>