<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
<title>Trench Run v26.2</title>
<style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { background: #000; overflow: hidden; touch-action: none; font-family: 'Courier New', monospace; color: #00E676; }
    #gameCanvas { display: block; }
    #ui { position: absolute; top: 20px; left: 20px; pointer-events: none; text-shadow: 2px 2px #000; z-index: 10; font-size: 18px; }
    #startBtn {
        position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
        padding: 20px 40px; font-size: 24px; background: #00E676; color: #000;
        border: none; border-radius: 4px; cursor: pointer; z-index: 100; font-weight: bold;
        box-shadow: 0 0 20px rgba(0, 230, 118, 0.5);
    }
</style>
</head>
<body>
<canvas id="gameCanvas"></canvas>
<div id="ui">DIST: <span id="dist">0</span>m | THRUST: <span id="thrust">0</span>%</div>
<button id="startBtn">ENGAGE ENGINES</button>

<script>
const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d");
const startBtn = document.getElementById("startBtn");

let gameRunning = false;
let touchL = false, touchR = false;
let keyL = false, keyR = false;
let tiltX = 0, tiltY = 0;
let baseGX = 0, baseGY = 0;
let distance = 0, frameCount = 0;
let speedMultiplier = 0.15; 

const CONFIG = {
    rotTorque: 0.0016, 
    driftSens: 0.15, 
    driftFriction: 0.90, 
    rotFriction: 0.96,
    trenchSpeedBase: 0.007, 
    curveDrift: 180, 
    gateFrequency: 25,      
    maxZ: 5.0,
    visibleTrenchDepth: 5   
};

let ship = { 
    x: 0, y: 0, vx: 0, vy: 0, angle: -Math.PI/2, vAngle: 0,
    w: 80, h: 8 
};

let gates = []; 
let stars = []; 
let pathX = 0, pathY = 0; 
let lastAcc = null;

function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    ship.x = canvas.width / 2; ship.y = canvas.height / 2;
    initStars();
}

function initStars() {
    stars = [];
    for(let i=0; i<60; i++) {
        stars.push({
            x: Math.random() * canvas.width - canvas.width/2,
            y: Math.random() * canvas.height - canvas.height/2,
            z: Math.random() * CONFIG.maxZ
        });
    }
}

window.addEventListener("resize", resize);
resize();

// --- Input Management ---

window.addEventListener("touchstart", (e) => {
    if (!gameRunning) return;
    for(let t of e.touches) (t.clientX < canvas.width/2) ? touchL = true : touchR = true;
});
window.addEventListener("touchend", () => { touchL = false; touchR = false; });

window.addEventListener("keydown", (e) => {
    if(e.key === "ArrowLeft") keyL = true;
    if(e.key === "ArrowRight") keyR = true;
});
window.addEventListener("keyup", (e) => {
    if(e.key === "ArrowLeft") keyL = false;
    if(e.key === "ArrowRight") keyR = false;
});

window.addEventListener("devicemotion", (e) => {
    lastAcc = e.accelerationIncludingGravity;
    if (!gameRunning || !lastAcc) return;
    tiltY = Math.max(-3, Math.min(3, (lastAcc.x || 0) - baseGY));
    tiltX = Math.max(-3, Math.min(3, (lastAcc.y || 0) - baseGX));
});

// --- Gameplay Logic ---

function spawnGate(customZ) {
    gates.push({ 
        z: customZ || CONFIG.maxZ, 
        cx: pathX, 
        cy: pathY, 
        w: canvas.width * 0.45, 
        h: canvas.height * 0.45 
    });
}

function initTrench() {
    gates = [];
    distance = 0;
    frameCount = 0;
    speedMultiplier = 0.15;
    // Fixes the "confusing start" by spawning a consistent set of gates
    for(let i=1; i<=5; i++) {
        spawnGate(i * 1.0);
    }
}

function update() {
    if (!gameRunning) return;
    
    if (speedMultiplier < 1.0) speedMultiplier += 0.0008; 
    let currentSpeed = CONFIG.trenchSpeedBase * speedMultiplier;
    distance += currentSpeed * 50;
    frameCount++;

    // Procedural Path
    pathX = Math.sin(frameCount * 0.012) * CONFIG.curveDrift;
    pathY = Math.cos(frameCount * 0.008) * (CONFIG.curveDrift * 0.4);

    if (frameCount % CONFIG.gateFrequency === 0) spawnGate();

    // Movement Physics
    if (touchL || keyL) ship.vAngle -= CONFIG.rotTorque;
    if (touchR || keyR) ship.vAngle += CONFIG.rotTorque;
    ship.angle += ship.vAngle; ship.vAngle *= CONFIG.rotFriction;
    ship.vx += tiltX * CONFIG.driftSens; ship.vy += tiltY * CONFIG.driftSens;
    ship.x += ship.vx; ship.y += ship.vy;
    ship.vx *= CONFIG.driftFriction; ship.vy *= CONFIG.driftFriction;

    ship.x = Math.max(20, Math.min(canvas.width - 20, ship.x));
    ship.y = Math.max(20, Math.min(canvas.height - 20, ship.y));

    // Star/Speedline movement
    stars.forEach(s => {
        s.z -= currentSpeed * 2;
        if(s.z <= 0) s.z = CONFIG.maxZ;
    });

    // Gate Updates & Collision Check
    for (let i = gates.length - 1; i >= 0; i--) {
        let prevZ = gates[i].z;
        gates[i].z -= currentSpeed;
        
        // Exact plane collision check at ship's Z-depth (0.2)
        if (prevZ > 0.2 && gates[i].z <= 0.2) {
            const dPct = Math.pow(1 - (0.2 / CONFIG.maxZ), 2);
            const cX = (canvas.width / 2) + gates[i].cx * dPct;
            const cY = (canvas.height / 2) + gates[i].cy * dPct;
            
            const gW = (canvas.width * 0.45);
            const gH = (canvas.height * 0.45);

            if (Math.abs(ship.x - cX) > gW/2 || Math.abs(ship.y - cY) > gH/2) {
                gameOver();
            }
        }
        if (gates[i].z <= 0) gates.splice(i, 1);
    }

    document.getElementById("dist").innerText = Math.floor(distance);
    document.getElementById("thrust").innerText = Math.floor(speedMultiplier * 100);
}

function gameOver() {
    gameRunning = false;
    ctx.fillStyle = "rgba(255, 0, 0, 0.4)";
    ctx.fillRect(0,0,canvas.width,canvas.height);
    setTimeout(() => { 
        startBtn.style.display = "block";
        startBtn.innerText = "RETRY MISSION";
    }, 500);
}

function draw() {
    ctx.fillStyle = "#000"; ctx.fillRect(0, 0, canvas.width, canvas.height);
    if (!gameRunning) return;

    const mx = canvas.width / 2, my = canvas.height / 2;

    // Draw Speed Lines (The "Visual Anchor")
    ctx.strokeStyle = "rgba(255, 255, 255, 0.2)";
    stars.forEach(s => {
        let sz = Math.pow(1 - (s.z / CONFIG.maxZ), 2);
        let sx = mx + s.x * sz; let sy = my + s.y * sz;
        ctx.beginPath();
        ctx.moveTo(sx, sy);
        ctx.lineTo(sx + (s.x * 0.05), sy + (s.y * 0.05));
        ctx.stroke();
    });

    // Draw Trench
    for (let i = gates.length - 1; i >= 0; i--) {
        let g = gates[i];
        let dPct = Math.pow(1 - (g.z / CONFIG.maxZ), 2); 
        let scale = 0.05 + dPct * 2.5; 
        
        let sW = (canvas.width * 0.45) * scale; let sH = (canvas.height * 0.45) * scale;
        let sX = mx + g.cx * dPct; let sY = my + g.cy * dPct;

        let isNearest = (i === 0);
        let alpha = Math.min(1, dPct * 1.5);
        
        ctx.strokeStyle = isNearest ? `rgba(255, 255, 255, ${alpha})` : `rgba(0, 230, 118, ${alpha * 0.5})`;
        ctx.lineWidth = isNearest ? 3 : 1;
        ctx.strokeRect(sX - sW/2, sY - sH/2, sW, sH);

        // Connecting Ribs (Restricted depth for clarity)
        if (i < CONFIG.visibleTrenchDepth && i < gates.length - 1) {
            let n = gates[i+1];
            let nPct = Math.pow(1 - (n.z / CONFIG.maxZ), 2);
            let nScale = 0.05 + nPct * 2.5;
            let nX = mx + n.cx * nPct, nY = my + n.cy * nPct;
            let nW = (canvas.width * 0.45) * nScale, nH = (canvas.height * 0.45) * nScale;

            ctx.strokeStyle = `rgba(255, 140, 0, ${0.4 / (i + 1)})`;
            ctx.beginPath();
            ctx.moveTo(sX-sW/2, sY-sH/2); ctx.lineTo(nX-nW/2, nY-nH/2);
            ctx.moveTo(sX+sW/2, sY-sH/2); ctx.lineTo(nX+nW/2, nY-nH/2);
            ctx.moveTo(sX-sW/2, sY+sH/2); ctx.lineTo(nX-nW/2, nY+nH/2);
            ctx.moveTo(sX+sW/2, sY+sH/2); ctx.lineTo(nX+nW/2, nY+nH/2);
            ctx.stroke();
        }
    }

    // Draw Ship
    ctx.save();
    ctx.translate(ship.x, ship.y); ctx.rotate(ship.angle);
    ctx.strokeStyle = "#fff"; ctx.lineWidth = 2;
    ctx.shadowBlur = 10; ctx.shadowColor = "#00E676";
    ctx.beginPath();
    ctx.moveTo(20, 0); 
    ctx.lineTo(-10, -ship.w/2); ctx.lineTo(-5, 0); ctx.lineTo(-10, ship.w/2);
    ctx.closePath(); ctx.stroke();
    ctx.fillStyle = "#00E676"; ctx.fillRect(-12, -8, 3, 16);
    ctx.restore();
}

function loop() { update(); draw(); requestAnimationFrame(loop); }
loop();

// --- Fixed System Initialization ---
startBtn.addEventListener("click", async () => {
    // 1. Request permission for iOS/Safari (wrapped in try/catch to prevent crashes)
    if (typeof DeviceMotionEvent !== 'undefined' && typeof DeviceMotionEvent.requestPermission === 'function') {
        try { 
            await DeviceMotionEvent.requestPermission(); 
        } catch(e) { 
            console.log("Sensor access denied or not supported"); 
        }
    }
    
    // 2. Calibrate baseline ONLY if sensors are active
    if (lastAcc) { 
		baseGY = Number(lastAcc?.x) || 0; 
		baseGX = Number(lastAcc?.y) || 0; 
    }

    // 3. START GAME (Moved outside the 'if' so it always works)
    initTrench(); 
    gameRunning = true; 
    startBtn.style.display = "none"; 
});