<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Tilt Square</title>

<style>
* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}
body {
    background: #1a1a1a;
    overflow: hidden;
    touch-action: none;
}
#gameCanvas {
    display: block;
    background: #0a0a0a;
}
#startBtn {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    padding: 20px 40px;
    font-size: 24px;
    background: #4CAF50;
    color: white;
    border: none;
    border-radius: 10px;
    cursor: pointer;
}
#score {
    position: absolute;
    top: 10px;
    left: 50%;
    transform: translateX(-50%);
    font-size: 24px;
    color: white;
    font-family: monospace;
}
</style>
</head>

<body>
<canvas id="gameCanvas"></canvas>
<div id="score">Time: 0.0s</div>
<button id="startBtn">START</button>

<script>
/* =======================
   CANVAS SETUP
======================= */
const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d");
const startBtn = document.getElementById("startBtn");
const scoreEl = document.getElementById("score");

function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
}
resize();
window.addEventListener("resize", resize);

/* =======================
   GAME STATE
======================= */
let gameRunning = false;
let startTime = 0;
let activeQuadrant = null;

// Tilt data
let baseBeta = 0;
let baseGamma = 0;
let tiltX = 0;
let tiltY = 0;

/* =======================
   POINTS
======================= */
let points = [];

function resetPoints() {
    points = [
        { x: canvas.width * 0.3, y: canvas.height * 0.3, vx: 0, vy: 0 }, // TL
        { x: canvas.width * 0.7, y: canvas.height * 0.3, vx: 0, vy: 0 }, // TR
        { x: canvas.width * 0.3, y: canvas.height * 0.7, vx: 0, vy: 0 }, // BL
        { x: canvas.width * 0.7, y: canvas.height * 0.7, vx: 0, vy: 0 }  // BR
    ];
}

function randomizePoint(i) {
    const speed = 0.8;
    const a = Math.random() * Math.PI * 2;
    points[i].vx = Math.cos(a) * speed;
    points[i].vy = Math.sin(a) * speed;
}

function randomizeAll() {
    for (let i = 0; i < points.length; i++) {
        randomizePoint(i);
    }
}

/* =======================
   ORIENTATION CONTROL
======================= */
function handleOrientation(e) {
    if (e.beta == null || e.gamma == null) return;

    // Landscape-friendly mapping
    tiltX = e.gamma - baseGamma; // left / right
    tiltY = e.beta  - baseBeta;  // forward / back

    tiltX = Math.max(-30, Math.min(30, tiltX));
    tiltY = Math.max(-30, Math.min(30, tiltY));
}

/* =======================
   TOUCH CONTROLS
======================= */
canvas.addEventListener("touchstart", e => {
    e.preventDefault();
    const t = e.touches[0];
    const r = canvas.getBoundingClientRect();
    const x = t.clientX - r.left;
    const y = t.clientY - r.top;

    const mx = canvas.width / 2;
    const my = canvas.height / 2;

    if (x < mx && y < my) activeQuadrant = 0;
    else if (x >= mx && y < my) activeQuadrant = 1;
    else if (x < mx && y >= my) activeQuadrant = 2;
    else activeQuadrant = 3;

    // Randomize the other 3
    for (let i = 0; i < points.length; i++) {
        if (i !== activeQuadrant) randomizePoint(i);
    }
});

canvas.addEventListener("touchend", () => {
    activeQuadrant = null;
});

/* =======================
   GEOMETRY CHECK
======================= */
function linesIntersect(p1, p2, p3, p4) {
    const d =
        (p2.x - p1.x) * (p4.y - p3.y) -
        (p2.y - p1.y) * (p4.x - p3.x);

    if (d === 0) return false;

    const u =
        ((p3.x - p1.x) * (p4.y - p3.y) -
         (p3.y - p1.y) * (p4.x - p3.x)) / d;

    const v =
        ((p3.x - p1.x) * (p2.y - p1.y) -
         (p3.y - p1.y) * (p2.x - p1.x)) / d;

    return u > 0 && u < 1 && v > 0 && v < 1;
}

function squareValid() {
    const edges = [
        [0,1],[1,3],[3,2],[2,0]
    ];

    for (let i = 0; i < edges.length; i++) {
        for (let j = i + 2; j < edges.length; j++) {
            if (i === 0 && j === 2) continue;
            const [a,b] = edges[i];
            const [c,d] = edges[j];
            if (linesIntersect(points[a], points[b], points[c], points[d])) {
                return false;
            }
        }
    }
    return true;
}

/* =======================
   UPDATE LOOP
======================= */
function update() {
    if (!gameRunning) return;

    points.forEach((p, i) => {
        if (i === activeQuadrant && activeQuadrant !== null) {
            const angle = Math.atan2(tiltY, tiltX);
            const mag = Math.hypot(tiltX, tiltY);
            const speed = Math.min(mag * 0.1, 5);

            p.vx = Math.cos(angle) * speed;
            p.vy = Math.sin(angle) * speed;
        } else {
            // light damping for uncontrolled points
            p.vx *= 0.99;
            p.vy *= 0.99;
        }

        p.x += p.vx;
        p.y += p.vy;

        if (p.x < 20 || p.x > canvas.width - 20) p.vx *= -1;
        if (p.y < 20 || p.y > canvas.height - 20) p.vy *= -1;
    });

    if (!squareValid()) {
        gameRunning = false;
        alert(`Game Over! Time: ${((Date.now() - startTime)/1000).toFixed(1)}s`);
        startBtn.style.display = "block";
    }
}

/* =======================
   DRAW
======================= */
function draw() {
    ctx.fillStyle = "#0a0a0a";
    ctx.fillRect(0,0,canvas.width,canvas.height);

    ctx.strokeStyle = "rgba(255,255,255,0.1)";
    ctx.beginPath();
    ctx.moveTo(canvas.width/2,0);
    ctx.lineTo(canvas.width/2,canvas.height);
    ctx.moveTo(0,canvas.height/2);
    ctx.lineTo(canvas.width,canvas.height/2);
    ctx.stroke();

    if (activeQuadrant !== null) {
        ctx.fillStyle = "rgba(76,175,80,0.15)";
        const qx = activeQuadrant % 2 === 0 ? 0 : canvas.width/2;
        const qy = activeQuadrant < 2 ? 0 : canvas.height/2;
        ctx.fillRect(qx, qy, canvas.width/2, canvas.height/2);
    }

    ctx.strokeStyle = "#4CAF50";
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.moveTo(points[0].x, points[0].y);
    ctx.lineTo(points[1].x, points[1].y);
    ctx.lineTo(points[3].x, points[3].y);
    ctx.lineTo(points[2].x, points[2].y);
    ctx.closePath();
    ctx.stroke();

    points.forEach((p,i)=>{
        ctx.fillStyle = i === activeQuadrant ? "#FFD700" : "#FF5722";
        ctx.beginPath();
        ctx.arc(p.x,p.y,10,0,Math.PI*2);
        ctx.fill();
    });

    if (gameRunning) {
        scoreEl.textContent =
            `Time: ${((Date.now()-startTime)/1000).toFixed(1)}s`;
    }
}

/* =======================
   LOOP
======================= */
function loop() {
    update();
    draw();
    requestAnimationFrame(loop);
}
loop();

/* =======================
   START GAME
======================= */
startBtn.addEventListener("click", () => {
    startBtn.style.display = "none";
    gameRunning = true;
    startTime = Date.now();

    resetPoints();
    randomizeAll();

    function calibrate(e) {
        baseBeta = e.beta || 0;
        baseGamma = e.gamma || 0;
        window.removeEventListener("deviceorientation", calibrate);
        console.log("Calibrated:", baseBeta, baseGamma);
    }

    window.addEventListener("deviceorientation", calibrate);
    window.addEventListener("deviceorientation", handleOrientation);
});
</script>
</body>
</html>
