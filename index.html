<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
<title>Tilt Test v4</title>

<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { background: #1a1a1a; overflow: hidden; touch-action: none; font-family: monospace; }
#gameCanvas { display: block; background: #0a0a0a; }
#startBtn {
    position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
    padding: 20px 60px; font-size: 32px; background: #4CAF50; color: white;
    border: none; border-radius: 12px; cursor: pointer; z-index: 10;
}
#info { position: absolute; top: 16px; left: 16px; font-size: 18px; color: white; z-index: 5; line-height: 1.6; }
#version { position: absolute; bottom: 16px; right: 16px; font-size: 14px; color: rgba(255,255,255,0.5); z-index: 5; }
</style>
</head>
<body>
<canvas id="gameCanvas"></canvas>
<div id="info">
    Version 4<br>
    TiltX: <span id="tiltX">0</span><br>
    TiltY: <span id="tiltY">0</span><br>
    Orient: <span id="orient">detecting...</span>
</div>
<div id="version">v4.0</div>
<button id="startBtn">START</button>

<script>
const VERSION = 4;

const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d");
const startBtn = document.getElementById("startBtn");

function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
}
resize();
window.addEventListener("resize", resize);

let gameRunning = false;
let tiltX = 0;
let tiltY = 0;

// Dot physics
let dot = {
    x: 0, y: 0,
    vx: 0, vy: 0,
    radius: 20,
    friction: 0.98,
    gravityMulti: 0.25 // Sensitivity
};

function resetDot() {
    dot.x = canvas.width / 2;
    dot.y = canvas.height / 2;
    dot.vx = 0;
    dot.vy = 0;
}

function handleMotion(e) {
    if (!e.accelerationIncludingGravity) return;
    
    // In mobile browsers:
    // x: + left, y: + bottom-to-top, z: + skyward
    // We invert them so the ball "falls" toward the tilt.
    let accelX = e.accelerationIncludingGravity.x;
    let accelY = e.accelerationIncludingGravity.y;

    // Detect screen orientation (landscape vs portrait)
    // window.orientation is deprecated but still the most reliable for simple games
    const rotation = window.orientation || 0;

    if (rotation === 0) {
        // Portrait: X is left/right, Y is up/down
        tiltX = -accelX;
        tiltY = accelY;
    } else if (rotation === 90) {
        // Landscape (left): Y is left/right, X is up/down
        tiltX = accelY;
        tiltY = accelX;
    } else if (rotation === -90) {
        // Landscape (right): Y is left/right, X is up/down
        tiltX = -accelY;
        tiltY = -accelX;
    } else if (rotation === 180) {
        // Upside down
        tiltX = accelX;
        tiltY = -accelY;
    }

    document.getElementById('tiltX').textContent = tiltX.toFixed(2);
    document.getElementById('tiltY').textContent = tiltY.toFixed(2);
    document.getElementById('orient').textContent = rotation + "deg";
}

function update() {
    if (!gameRunning) return;

    // Apply tilt as ACCELERATION (adding to velocity)
    dot.vx += tiltX * dot.gravityMulti;
    dot.vy += tiltY * dot.gravityMulti;

    // Apply friction (so it doesn't slide forever)
    dot.vx *= dot.friction;
    dot.vy *= dot.friction;

    // Update position
    dot.x += dot.vx;
    dot.y += dot.vy;

    // Wall Collisions
    if (dot.x < dot.radius) {
        dot.x = dot.radius;
        dot.vx *= -0.5; // Bounce
    } else if (dot.x > canvas.width - dot.radius) {
        dot.x = canvas.width - dot.radius;
        dot.vx *= -0.5;
    }

    if (dot.y < dot.radius) {
        dot.y = dot.radius;
        dot.vy *= -0.5;
    } else if (dot.y > canvas.height - dot.radius) {
        dot.y = canvas.height - dot.radius;
        dot.vy *= -0.5;
    }
}

function draw() {
    ctx.fillStyle = "#0a0a0a";
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    if (!gameRunning) return;

    // Draw Target/Center
    ctx.strokeStyle = "rgba(255,255,255,0.1)";
    ctx.beginPath();
    ctx.arc(canvas.width/2, canvas.height/2, 50, 0, Math.PI*2);
    ctx.stroke();

    // Draw dot
    ctx.shadowColor = "#00E676";
    ctx.shadowBlur = 15;
    ctx.fillStyle = "#00E676";
    ctx.beginPath();
    ctx.arc(dot.x, dot.y, dot.radius, 0, Math.PI * 2);
    ctx.fill();
    ctx.shadowBlur = 0;
}

function loop() {
    update();
    draw();
    requestAnimationFrame(loop);
}
loop();

async function startGame() {
    // Request permission for iOS 13+
    if (typeof DeviceMotionEvent.requestPermission === 'function') {
        try {
            const response = await DeviceMotionEvent.requestPermission();
            if (response !== 'granted') {
                alert("Permission denied");
                return;
            }
        } catch (e) {
            console.error(e);
        }
    }

    startBtn.style.display = "none";
    gameRunning = true;
    resetDot();
    window.addEventListener("devicemotion", handleMotion);
}

startBtn.addEventListener("click", startGame);
</script>
</body>
</html>