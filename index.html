<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
<title>Tilt Test</title>

<style>
* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}
body {
    background: #1a1a1a;
    overflow: hidden;
    touch-action: none;
    font-family: monospace;
}
#gameCanvas {
    display: block;
    background: #0a0a0a;
}
#startBtn {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    padding: 20px 60px;
    font-size: 32px;
    background: #4CAF50;
    color: white;
    border: none;
    border-radius: 12px;
    cursor: pointer;
    z-index: 10;
}
#info {
    position: absolute;
    top: 16px;
    left: 16px;
    font-size: 18px;
    color: white;
    z-index: 5;
    line-height: 1.6;
}
#version {
    position: absolute;
    bottom: 16px;
    right: 16px;
    font-size: 14px;
    color: rgba(255,255,255,0.5);
    z-index: 5;
}
</style>
</head>
<body>
<canvas id="gameCanvas"></canvas>
<div id="info">
    Version 2<br>
    TiltX: <span id="tiltX">0</span><br>
    TiltY: <span id="tiltY">0</span><br>
    BaseX: <span id="baseX">0</span><br>
    BaseY: <span id="baseY">0</span>
</div>
<div id="version">v2.0</div>
<button id="startBtn">START</button>

<script>
const VERSION = 2;

const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d");
const startBtn = document.getElementById("startBtn");

function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
}
resize();
window.addEventListener("resize", resize);

// Game state
let gameRunning = false;
let baseGravityX = 0;
let baseGravityY = 0;
let tiltX = 0;
let tiltY = 0;

// Single dot
let dot = {
    x: 0,
    y: 0,
    vx: 0,
    vy: 0
};

function resetDot() {
    dot.x = canvas.width / 2;
    dot.y = canvas.height / 2;
    dot.vx = 0;
    dot.vy = 0;
}

// GRAVITY-BASED tilt handling
function handleMotion(e) {
    if (!e.accelerationIncludingGravity) return;
    
    const gx = e.accelerationIncludingGravity.x;
    const gy = e.accelerationIncludingGravity.y;
    
    if (gx === null || gy === null) return;
    
    // Calculate relative tilt from baseline
    tiltX = gx - baseGravityX;
    tiltY = gy - baseGravityY;
    
    // Update debug display
    document.getElementById('tiltX').textContent = tiltX.toFixed(2);
    document.getElementById('tiltY').textContent = tiltY.toFixed(2);
    document.getElementById('baseX').textContent = baseGravityX.toFixed(2);
    document.getElementById('baseY').textContent = baseGravityY.toFixed(2);
}

// Update logic
function update() {
    if (!gameRunning) return;

    // Apply tilt to velocity
    const angle = Math.atan2(tiltY, tiltX);
    const mag = Math.hypot(tiltX, tiltY);
    const speed = Math.min(mag * 0.5, 8);
    
    dot.vx = Math.cos(angle) * speed;
    dot.vy = Math.sin(angle) * speed;

    // Update position
    dot.x += dot.vx;
    dot.y += dot.vy;

    // Bounce off walls
    if (dot.x < 30) {
        dot.x = 30;
        dot.vx *= -0.8;
    }
    if (dot.x > canvas.width - 30) {
        dot.x = canvas.width - 30;
        dot.vx *= -0.8;
    }
    if (dot.y < 30) {
        dot.y = 30;
        dot.vy *= -0.8;
    }
    if (dot.y > canvas.height - 30) {
        dot.y = canvas.height - 30;
        dot.vy *= -0.8;
    }
}

// Draw function
function draw() {
    ctx.fillStyle = "#0a0a0a";
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    if (!gameRunning) return;

    // Draw crosshair at center
    ctx.strokeStyle = "rgba(255,255,255,0.2)";
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(canvas.width/2 - 20, canvas.height/2);
    ctx.lineTo(canvas.width/2 + 20, canvas.height/2);
    ctx.moveTo(canvas.width/2, canvas.height/2 - 20);
    ctx.lineTo(canvas.width/2, canvas.height/2 + 20);
    ctx.stroke();

    // Draw velocity vector
    if (Math.hypot(dot.vx, dot.vy) > 0.5) {
        ctx.strokeStyle = "rgba(255,255,255,0.5)";
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(dot.x, dot.y);
        ctx.lineTo(dot.x + dot.vx * 10, dot.y + dot.vy * 10);
        ctx.stroke();
    }

    // Draw dot
    ctx.shadowColor = "#00E676";
    ctx.shadowBlur = 20;
    ctx.fillStyle = "#00E676";
    ctx.beginPath();
    ctx.arc(dot.x, dot.y, 20, 0, Math.PI * 2);
    ctx.fill();
    ctx.shadowBlur = 0;
}

function loop() {
    update();
    draw();
    requestAnimationFrame(loop);
}
loop();

// Start game
function startGame(e) {
    if (e) {
        e.preventDefault();
        e.stopPropagation();
    }
    if (gameRunning) return;

    startBtn.style.display = "none";
    gameRunning = true;

    resetDot();

    // Reset calibration
    baseGravityX = 0;
    baseGravityY = 0;

    // Calibrate on first motion event
    function calibrate(ev) {
        if (ev.accelerationIncludingGravity) {
            baseGravityX = ev.accelerationIncludingGravity.x || 0;
            baseGravityY = ev.accelerationIncludingGravity.y || 0;
            console.log(`Version ${VERSION} - Calibrated! X=${baseGravityX.toFixed(2)}, Y=${baseGravityY.toFixed(2)}`);
            document.getElementById('baseX').textContent = baseGravityX.toFixed(2);
            document.getElementById('baseY').textContent = baseGravityY.toFixed(2);
        }
    }

    window.addEventListener("devicemotion", calibrate, { once: true });
    
    setTimeout(() => {
        window.addEventListener("devicemotion", handleMotion);
    }, 100);
}

startBtn.addEventListener("click", startGame);
startBtn.addEventListener("touchstart", startGame);

console.log(`Tilt Test Version ${VERSION} loaded`);
</script>
</body>
</html>