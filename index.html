<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tilt Square</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            background: #1a1a1a;
            overflow: hidden;
            touch-action: none;
        }
        #gameCanvas {
            display: block;
            background: #0a0a0a;
        }
        #startBtn {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            padding: 20px 40px;
            font-size: 24px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 10px;
            cursor: pointer;
        }
        #score {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 24px;
            color: white;
            font-family: monospace;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <div id="score">Time: 0s</div>
    <button id="startBtn">START</button>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const startBtn = document.getElementById('startBtn');
        const scoreEl = document.getElementById('score');

        // Force landscape
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        
        // Game state
        let gameRunning = false;
        let startTime = 0;
        let tiltX = 0;
        let tiltY = 0;
        let activeQuadrant = null; // 0=TL, 1=TR, 2=BL, 3=BR

        // Four corner points
        let points = [
            { x: canvas.width * 0.3, y: canvas.height * 0.3, vx: 0, vy: 0 }, // Top Left
            { x: canvas.width * 0.7, y: canvas.height * 0.3, vx: 0, vy: 0 }, // Top Right
            { x: canvas.width * 0.3, y: canvas.height * 0.7, vx: 0, vy: 0 }, // Bottom Left
            { x: canvas.width * 0.7, y: canvas.height * 0.7, vx: 0, vy: 0 }  // Bottom Right
        ];

        // Initialize random velocities
        function randomizePoint(index) {
            const speed = 2;
            const angle = Math.random() * Math.PI * 2;
            points[index].vx = Math.cos(angle) * speed;
            points[index].vy = Math.sin(angle) * speed;
        }

        function randomizeAllPoints() {
            points.forEach((_, i) => randomizePoint(i));
        }

        // Check if lines intersect
        function linesIntersect(p1, p2, p3, p4) {
            const det = (p2.x - p1.x) * (p4.y - p3.y) - (p4.x - p3.x) * (p2.y - p1.y);
            if (det === 0) return false;
            
            const lambda = ((p4.y - p3.y) * (p4.x - p1.x) + (p3.x - p4.x) * (p4.y - p1.y)) / det;
            const gamma = ((p1.y - p2.y) * (p4.x - p1.x) + (p2.x - p1.x) * (p4.y - p1.y)) / det;
            
            return (0 < lambda && lambda < 1) && (0 < gamma && gamma < 1);
        }

        // Check if square is valid (no crossing lines)
        function isSquareValid() {
            // Check all line combinations
            // Lines: 0-1 (top), 1-3 (right), 3-2 (bottom), 2-0 (left)
            const lines = [
                [0, 1], // top
                [1, 3], // right
                [3, 2], // bottom
                [2, 0]  // left
            ];
            
            // Check if any edge crosses another edge
            for (let i = 0; i < lines.length; i++) {
                for (let j = i + 2; j < lines.length; j++) {
                    if (j === i + 2 && i === 0) continue; // Adjacent edges
                    
                    const [a1, a2] = lines[i];
                    const [b1, b2] = lines[j];
                    
                    if (linesIntersect(points[a1], points[a2], points[b1], points[b2])) {
                        return false;
                    }
                }
            }
            
            return true;
        }

        // Handle tilt
        function handleTilt(e) {
            if (e.beta === null || e.gamma === null) return;
            
            // In landscape: gamma is tilt left/right, beta is tilt forward/back
            tiltX = e.gamma;  // -90 to 90 (left to right)
            tiltY = e.beta;   // -180 to 180 (forward to back)
            
            // Normalize to reasonable range
            tiltX = Math.max(-45, Math.min(45, tiltX));
            tiltY = Math.max(-45, Math.min(45, tiltY));
        }

        // Handle touch to select quadrant
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            const rect = canvas.getBoundingClientRect();
            const x = touch.clientX - rect.left;
            const y = touch.clientY - rect.top;
            
            // Determine quadrant
            const midX = canvas.width / 2;
            const midY = canvas.height / 2;
            
            if (x < midX && y < midY) activeQuadrant = 0; // Top Left
            else if (x >= midX && y < midY) activeQuadrant = 1; // Top Right
            else if (x < midX && y >= midY) activeQuadrant = 2; // Bottom Left
            else activeQuadrant = 3; // Bottom Right
            
            // Randomize other 3 points
            points.forEach((_, i) => {
                if (i !== activeQuadrant) {
                    randomizePoint(i);
                }
            });
        });

        canvas.addEventListener('touchend', () => {
            activeQuadrant = null;
        });

        // Update physics
        function update() {
            if (!gameRunning) return;
            
            // Update each point
            points.forEach((p, i) => {
                if (i === activeQuadrant && activeQuadrant !== null) {
                    // Controlled by tilt - FULL 360Â° DIRECTION
                    // Calculate angle from tilt
                    const angle = Math.atan2(tiltY, tiltX);
                    // Calculate speed from tilt magnitude
                    const tiltMagnitude = Math.sqrt(tiltX * tiltX + tiltY * tiltY);
                    const speed = Math.min(tiltMagnitude * 0.015, 0.5); // Cap max speed
                    
                    // Set velocity based on tilt direction
                    p.vx = Math.cos(angle) * speed;
                    p.vy = Math.sin(angle) * speed;
                }
                
                // Move point
                p.x += p.vx;
                p.y += p.vy;
                
                // Bounce off walls
                if (p.x < 20 || p.x > canvas.width - 20) {
                    p.vx *= -1;
                    p.x = Math.max(20, Math.min(canvas.width - 20, p.x));
                }
                if (p.y < 20 || p.y > canvas.height - 20) {
                    p.vy *= -1;
                    p.y = Math.max(20, Math.min(canvas.height - 20, p.y));
                }
            });
            
            // Check if square is still valid
            if (!isSquareValid()) {
                gameRunning = false;
                alert(`Game Over! Time: ${((Date.now() - startTime) / 1000).toFixed(1)}s`);
                startBtn.style.display = 'block';
            }
        }

        // Draw
        function draw() {
            // Clear
            ctx.fillStyle = '#0a0a0a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw quadrant dividers (faint)
            ctx.strokeStyle = 'rgba(255,255,255,0.1)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(canvas.width / 2, 0);
            ctx.lineTo(canvas.width / 2, canvas.height);
            ctx.moveTo(0, canvas.height / 2);
            ctx.lineTo(canvas.width, canvas.height / 2);
            ctx.stroke();
            
            // Highlight active quadrant
            if (activeQuadrant !== null) {
                ctx.fillStyle = 'rgba(76, 175, 80, 0.1)';
                const qx = activeQuadrant % 2 === 0 ? 0 : canvas.width / 2;
                const qy = activeQuadrant < 2 ? 0 : canvas.height / 2;
                ctx.fillRect(qx, qy, canvas.width / 2, canvas.height / 2);
            }
            
            // Draw square (connect the 4 points)
            ctx.strokeStyle = '#4CAF50';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(points[0].x, points[0].y);
            ctx.lineTo(points[1].x, points[1].y);
            ctx.lineTo(points[3].x, points[3].y);
            ctx.lineTo(points[2].x, points[2].y);
            ctx.closePath();
            ctx.stroke();
            
            // Draw points
            points.forEach((p, i) => {
                ctx.fillStyle = i === activeQuadrant ? '#FFD700' : '#FF5722';
                ctx.beginPath();
                ctx.arc(p.x, p.y, 10, 0, Math.PI * 2);
                ctx.fill();
                
                // Label
                ctx.fillStyle = 'white';
                ctx.font = '12px monospace';
                ctx.textAlign = 'center';
                const labels = ['TL', 'TR', 'BL', 'BR'];
                ctx.fillText(labels[i], p.x, p.y - 15);
            });
            
            // Update score
            if (gameRunning) {
                const elapsed = ((Date.now() - startTime) / 1000).toFixed(1);
                scoreEl.textContent = `Time: ${elapsed}s`;
            }
        }

        // Game loop
        function gameLoop() {
            update();
            draw();
            requestAnimationFrame(gameLoop);
        }

        // Start game
        function startGame() {
            startBtn.style.display = 'none';
            gameRunning = true;
            startTime = Date.now();
            
            // Reset points to corners
            points = [
                { x: canvas.width * 0.3, y: canvas.height * 0.3, vx: 0, vy: 0 },
                { x: canvas.width * 0.7, y: canvas.height * 0.3, vx: 0, vy: 0 },
                { x: canvas.width * 0.3, y: canvas.height * 0.7, vx: 0, vy: 0 },
                { x: canvas.width * 0.7, y: canvas.height * 0.7, vx: 0, vy: 0 }
            ];
            
            randomizeAllPoints();
            
            window.addEventListener('deviceorientation', handleTilt);
        }

        startBtn.addEventListener('click', startGame);
        gameLoop();

        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        });
    </script>
</body>
</html>