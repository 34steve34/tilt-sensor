<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
<title>Tilt Test v7</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { background: #1a1a1a; overflow: hidden; touch-action: none; font-family: monospace; }
#gameCanvas { display: block; background: #0a0a0a; }
#startBtn {
    position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
    padding: 20px 60px; font-size: 24px; background: #9C27B0; color: white;
    border: none; border-radius: 12px; cursor: pointer; z-index: 10;
}
#info { position: absolute; top: 16px; left: 16px; font-size: 16px; color: white; z-index: 5; line-height: 1.4; }
#version { position: absolute; bottom: 16px; right: 16px; font-size: 14px; color: rgba(255,255,255,0.5); }
</style>
</head>
<body>
<canvas id="gameCanvas"></canvas>
<div id="info">
    Version 7 (Auto-Calibrate)<br>
    RelX: <span id="tiltX">0</span><br>
    RelY: <span id="tiltY">0</span><br>
    <span id="status" style="color: #E91E63;">Hold phone comfortably and press START</span>
</div>
<div id="version">v7.0</div>
<button id="startBtn">START & CALIBRATE</button>

<script>
const VERSION = 7;
const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d");
const startBtn = document.getElementById("startBtn");

let gameRunning = false;
let tiltX = 0;
let tiltY = 0;

// Calibration Baselines
let baseGX = 0;
let baseGY = 0;
let baseGZ = 0;

let dot = {
    x: 0, y: 0,
    vx: 0, vy: 0,
    radius: 20,
    friction: 0.93,
    sensitivity: 0.6 // Adjust this for "weight"
};

function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
}
resize();
window.addEventListener("resize", resize);

function handleMotion(e) {
    const acc = e.accelerationIncludingGravity;
    if (!acc) return;

    // Calculate the difference from our starting "Zero" point
    // We use a simple subtraction to find the relative tilt
    let dx = acc.x - baseGX;
    let dy = acc.y - baseGY;
    let dz = acc.z - baseGZ;

    const rot = window.orientation || 0;

    // Map the deltas to screen space based on orientation
    if (rot === 0) {
        tiltX = -dx;
        tiltY = dy;
    } else if (rot === 90) {
        tiltX = dy;
        tiltY = dx;
    } else if (rot === -90) {
        tiltX = -dy;
        tiltY = -dx;
    }

    document.getElementById('tiltX').textContent = tiltX.toFixed(2);
    document.getElementById('tiltY').textContent = tiltY.toFixed(2);
}

function update() {
    if (!gameRunning) return;

    // Deadzone to prevent micro-drifting
    const deadzone = 0.4;
    let forceX = Math.abs(tiltX) > deadzone ? tiltX : 0;
    let forceY = Math.abs(tiltY) > deadzone ? tiltY : 0;

    dot.vx += forceX * dot.sensitivity;
    dot.vy += forceY * dot.sensitivity;

    dot.vx *= dot.friction;
    dot.vy *= dot.friction;

    dot.x += dot.vx;
    dot.y += dot.vy;

    // Bounds
    if (dot.x < dot.radius) { dot.x = dot.radius; dot.vx *= -0.5; }
    if (dot.x > canvas.width - dot.radius) { dot.x = canvas.width - dot.radius; dot.vx *= -0.5; }
    if (dot.y < dot.radius) { dot.y = dot.radius; dot.vy *= -0.5; }
    if (dot.y > canvas.height - dot.radius) { dot.y = canvas.height - dot.radius; dot.vy *= -0.5; }
}

function draw() {
    ctx.fillStyle = "#0a0a0a";
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    if (!gameRunning) return;

    // Draw "Zero Point" indicator
    ctx.strokeStyle = "rgba(156, 39, 176, 0.4)";
    ctx.lineWidth = 2;
    ctx.strokeRect(canvas.width/2 - 10, canvas.height/2 - 10, 20, 20);

    // The Ball
    ctx.shadowColor = "#E91E63";
    ctx.shadowBlur = 15;
    ctx.fillStyle = "#E91E63";
    ctx.beginPath();
    ctx.arc(dot.x, dot.y, dot.radius, 0, Math.PI * 2);
    ctx.fill();
    ctx.shadowBlur = 0;
}

function loop() {
    update();
    draw();
    requestAnimationFrame(loop);
}
loop();

async function startGame() {
    // 1. Permissions (iOS)
    if (typeof DeviceMotionEvent.requestPermission === 'function') {
        const response = await DeviceMotionEvent.requestPermission();
        if (response !== 'granted') return;
    }

    // 2. Calibration Snapshot
    // We listen for exactly one event to "set the floor"
    const captureBaseline = (e) => {
        const acc = e.accelerationIncludingGravity;
        baseGX = acc.x;
        baseGY = acc.y;
        baseGZ = acc.z;
        
        console.log(`Calibrated to: ${baseGX}, ${baseGY}, ${baseGZ}`);
        
        // Start the game loop only after calibration
        startBtn.style.display = "none";
        gameRunning = true;
        dot.x = canvas.width / 2;
        dot.y = canvas.height / 2;
        document.getElementById('status').textContent = "Calibrated! Tilt to slide.";
        
        window.addEventListener("devicemotion", handleMotion);
    };

    window.addEventListener("devicemotion", captureBaseline, { once: true });
}

startBtn.addEventListener("click", startGame);
</script>
</body>
</html>