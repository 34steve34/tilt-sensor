<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
<title>Space Slalom v34.1</title>
<style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { background: #000; overflow: hidden; touch-action: none; font-family: 'Courier New', monospace; color: #00E676; }
    #gameCanvas { display: block; }
    #ui { position: absolute; top: 20px; left: 20px; pointer-events: none; text-shadow: 2px 2px #000; z-index: 10; font-size: 18px; }
    #startBtn {
        position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
        padding: 20px 40px; font-size: 24px; background: #00E676; color: #000;
        border: none; border-radius: 4px; cursor: pointer; z-index: 100; font-weight: bold;
    }
</style>
</head>
<body>
<canvas id="gameCanvas"></canvas>
<div id="ui">SLALOM v34.1 | SPEED: <span id="thrust">0</span>%</div>
<button id="startBtn">ENGAGE SLALOM</button>

<script>
const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d");
const startBtn = document.getElementById("startBtn");

let gameRunning = false;
let isPaused = false;
let touchL = false, touchR = false;
let tiltX = 0, tiltY = 0;
let baseGX = 0, baseGY = 0; 
let frameCount = 0;
let speedMultiplier = 1.0; 

const CONFIG = {
    rotTorque: 0.0025,    
    driftSens: 0.4,      
    driftFriction: 0.8,  
    rotFriction: 0.9,    
    speedBase: 0.08,      // Linear speed base
    gateInterval: 40,     // (unused by new system, kept for reference)
    maxZ: 100,            // Linear Z-depth
    gateSizeBase: 0.6,    // 60% of screen height
    gateAspect: 2.5
};

let ship = { x: 0, y: 0, vx: 0, vy: 0, angle: -Math.PI/2, vAngle: 0, w: 60, h: 6 };
let gates = []; 
let stars = []; 
let lastAcc = null;

// *** NEW: simple state to control gate spacing
let readyForNextGate = false;          // when true, we are allowed to spawn the next gate
let gateCooldownFrames = 40;          // how many frames to wait AFTER a gate leaves before spawning next
let gateCooldownCounter = 0;          // counts up during cooldown

function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    ship.x = canvas.width / 2; ship.y = canvas.height / 2;
    initStars();
}

function initStars() {
    stars = [];
    for(let i=0; i<100; i++) {
        stars.push({
            x: Math.random() * canvas.width - canvas.width/2,
            y: Math.random() * canvas.height - canvas.height/2,
            z: Math.random() * CONFIG.maxZ
        });
    }
}

window.addEventListener("resize", resize);
resize();

window.addEventListener("touchstart", (e) => {
    if (!gameRunning || isPaused) return;
    for(let t of e.touches) (t.clientX < canvas.width/2) ? touchL = true : touchR = true;
});
window.addEventListener("touchend", () => { touchL = false; touchR = false; });

window.addEventListener("devicemotion", (e) => {
    lastAcc = e.accelerationIncludingGravity;
    if (!gameRunning || isPaused || !lastAcc) return;
    tiltX = (lastAcc.y || 0) - baseGY; 
    tiltY = (lastAcc.x || 0) - (baseGX || 6); 
});

function spawnGate() {
    gates.push({ 
        z: CONFIG.maxZ, 
        x: (Math.random() - 0.5) * canvas.width * 1.5, 
        y: (Math.random() - 0.5) * canvas.height * 1.2, 
        roll: (Math.random() - 0.5) * Math.PI,
        passed: false
    });
}

function initGame() {
    gates = []; frameCount = 0; isPaused = false;
    ship.x = canvas.width / 2; ship.y = canvas.height / 2;
    ship.vx = 0; ship.vy = 0; ship.angle = -Math.PI/2; ship.vAngle = 0;

    // *** NEW: reset spacing state, spawn ONE gate far ahead
    readyForNextGate = false;
    gateCooldownCounter = 0;
    spawnGate();
}

function update() {
    if (!gameRunning || isPaused) return;
    frameCount++;

    // *** REMOVED: frame-based spawning
    // if (frameCount % CONFIG.gateInterval === 0) spawnGate();

    // Movement
    if (touchL) ship.vAngle -= CONFIG.rotTorque;
    if (touchR) ship.vAngle += CONFIG.rotTorque;
    ship.angle += ship.vAngle; ship.vAngle *= CONFIG.rotFriction;
    ship.vx += tiltX * CONFIG.driftSens; ship.vy += tiltY * CONFIG.driftSens;
    ship.x += ship.vx; ship.y += ship.vy;
    ship.vx *= CONFIG.driftFriction; ship.vy *= CONFIG.driftFriction;
    ship.x = Math.max(0, Math.min(canvas.width, ship.x));
    ship.y = Math.max(0, Math.min(canvas.height, ship.y));

    // Linear Star Movement
    stars.forEach(s => {
        s.z -= CONFIG.speedBase * 2;
        if(s.z <= 0) s.z = CONFIG.maxZ;
    });

    // Linear Gate Movement & Collision
    for (let i = gates.length - 1; i >= 0; i--) {
        let g = gates[i];
        g.z -= CONFIG.speedBase;

        // COLLISION: Only check when the gate is physically at the ship's plane (Z close to 0)
        if (!g.passed && g.z <= 1 && g.z >= -1) {
            let sW = canvas.height * CONFIG.gateSizeBase;
            let sH = sW / CONFIG.gateAspect;
            
            // Relational Math (is ship inside the box?)
            let dx = ship.x - (canvas.width/2 + g.x * (g.z/CONFIG.maxZ)); 
            let dy = ship.y - (canvas.height/2 + g.y * (g.z/CONFIG.maxZ));
            let rx = dx * Math.cos(-g.roll) - dy * Math.sin(-g.roll);
            let ry = dx * Math.sin(-g.roll) + dy * Math.cos(-g.roll);

            if (Math.abs(rx) > sW/2 || Math.abs(ry) > sH/2) {
                isPaused = true;
                setTimeout(() => { gameRunning = false; startBtn.style.display = "block"; }, 3000);
            }
            g.passed = true;
        }

        // When gate is far behind the ship, remove it and start cooldown
        if (g.z < -5) {
            gates.splice(i, 1);

            // *** NEW: Once the last visible gate is gone, start cooldown before next
            if (gates.length === 0) {
                readyForNextGate = false;
                gateCooldownCounter = 0;
            }
        }
    }

    // *** NEW: handle cooldown and spawn next gate when the “lane” is clear
    if (gates.length === 0) {
        if (!readyForNextGate) {
            gateCooldownCounter++;
            if (gateCooldownCounter >= gateCooldownFrames) {
                readyForNextGate = true;
            }
        } else {
            // “One gate, then time to prepare, then the next”
            spawnGate();
            readyForNextGate = false;
            gateCooldownCounter = 0;
        }
    }
}

function draw() {
    ctx.fillStyle = "#000"; ctx.fillRect(0, 0, canvas.width, canvas.height);
    if (!gameRunning) return;
    const mx = canvas.width / 2, my = canvas.height / 2;

    stars.forEach(s => {
        let scale = 1 - (s.z / CONFIG.maxZ);
        ctx.fillStyle = `rgba(255, 255, 255, ${scale})`;
        ctx.fillRect(mx + s.x * scale, my + s.y * scale, 2, 2);
    });

    for (let i = 0; i < gates.length; i++) {
        let g = gates[i];
        let scale = 1 - (g.z / CONFIG.maxZ);
        if (scale < 0) continue;

        let sW = (canvas.height * CONFIG.gateSizeBase) * (0.1 + scale * 2);
        let sH = sW / CONFIG.gateAspect;
        let sX = mx + g.x * scale; let sY = my + g.y * scale;

        ctx.save();
        ctx.translate(sX, sY); ctx.rotate(g.roll);
        
        // VISUAL SYNC: Gate turns white and glows ONLY when you are passing through it
        let isPassing = (g.z <= 10 && g.z >= -1);
        ctx.strokeStyle = isPassing ? "#fff" : `rgba(0, 230, 118, ${0.5 - (g.z/CONFIG.maxZ)})`;
        ctx.lineWidth = isPassing ? 6 : 2;
        
        if (isPassing) {
            ctx.fillStyle = "rgba(0, 230, 118, 0.2)";
            ctx.fillRect(-sW/2, -sH/2, sW, sH);
            ctx.shadowBlur = 20; ctx.shadowColor = "#fff";
        }

        ctx.strokeRect(-sW/2, -sH/2, sW, sH);
        ctx.restore();
    }

    // Ship
    ctx.save();
    ctx.translate(ship.x, ship.y); ctx.rotate(ship.angle);
    ctx.strokeStyle = isPaused ? "#f00" : "#fff"; 
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.moveTo(25, 0); ctx.lineTo(-10, -ship.w/2); ctx.lineTo(-5, 0); ctx.lineTo(-10, ship.w/2);
    ctx.closePath(); ctx.stroke();
    ctx.restore();
}

function loop() { update(); draw(); requestAnimationFrame(loop); }
loop();

startBtn.addEventListener("click", async () => {
    if (typeof DeviceMotionEvent !== 'undefined' && typeof DeviceMotionEvent.requestPermission === 'function') {
        try { await DeviceMotionEvent.requestPermission(); } catch(e) {}
    }
    if (lastAcc) { baseGY = lastAcc.y || 0; baseGX = lastAcc.x || 0; }
    initGame(); gameRunning = true; startBtn.style.display = "none";
});
</script>
</body>
</html>
