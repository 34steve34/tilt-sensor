<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
<title>Movement Lab v2.0</title>
<style>
    body { background: #080808; color: #00E676; font-family: 'Courier New', monospace; margin: 0; overflow: hidden; touch-action: none; }
    canvas { display: block; }
    #controls { position: absolute; top: 10px; left: 10px; background: rgba(0,0,0,0.8); padding: 15px; border: 1px solid #00E676; pointer-events: none; }
    .label { font-size: 12px; color: #fff; margin-bottom: 5px; }
</style>
</head>
<body>
<div id="controls">
    <div style="font-weight:bold; margin-bottom:10px; color:#00E676;">WIDE SWEEP LAB v2.0</div>
    <div class="label">Primary: Multi-Sine Sweep</div>
    <div class="label">Boundary: Elastic Tether</div>
    <div class="label">White Line: 4-Second History</div>
</div>
<canvas id="labCanvas"></canvas>

<script>
const canvas = document.getElementById("labCanvas");
const ctx = canvas.getContext("2d");

let width, height;
let target = { x: 0, y: 0 };
let trail = [];
let time = 0;

function resize() {
    width = canvas.width = window.innerWidth;
    height = canvas.height = window.innerHeight;
    target.x = width / 2;
    target.y = height / 2;
}

window.addEventListener("resize", resize);
resize();

function update() {
    time += 0.01;

    // 1. PRIMARY SINE ENGINE (The Broad Strokes)
    // We use different frequencies for X and Y to create the wide wandering
    let sweepX = (Math.sin(time * 0.8) * 0.4 + Math.sin(time * 0.3) * 0.1);
    let sweepY = (Math.cos(time * 0.7) * 0.3 + Math.cos(time * 0.4) * 0.15);

    // Convert normalized sweep to screen position
    let desiredX = (width / 2) + (sweepX * width);
    let desiredY = (height / 2) + (sweepY * height);

    // 2. THE ELASTIC TETHER
    // Instead of teleporting the target, we "Ease" toward the sine position.
    // This allows the "Noise" or "Momentum" to keep it from feeling too rigid.
    target.x += (desiredX - target.x) * 0.05;
    target.y += (desiredY - target.y) * 0.05;

    // 3. HARD BOUNDARY TETHER (The "Rubber Band")
    // If it gets within 10% of any edge, it gets pushed back toward center
    let margin = width * 0.1;
    if (target.x < margin) target.x += (margin - target.x) * 0.1;
    if (target.x > width - margin) target.x -= (target.x - (width - margin)) * 0.1;
    
    let marginY = height * 0.1;
    if (target.y < marginY) target.y += (marginY - target.y) * 0.1;
    if (target.y > height - marginY) target.y -= (target.y - (height - marginY)) * 0.1;

    // Trail logic (4 seconds at 60fps)
    trail.push({x: target.x, y: target.y});
    if (trail.length > 240) trail.shift(); 
}

function draw() {
    ctx.fillStyle = "#080808";
    ctx.fillRect(0, 0, width, height);

    // Draw the "Playable Area" boundary (Visual Aid)
    ctx.strokeStyle = "rgba(0, 230, 118, 0.1)";
    ctx.strokeRect(width * 0.1, height * 0.1, width * 0.8, height * 0.8);

    // Draw Path
    if (trail.length > 1) {
        ctx.strokeStyle = "rgba(255, 255, 255, 0.3)";
        ctx.setLineDash([5, 5]); // Dashed line for a "radar" look
        ctx.beginPath();
        ctx.moveTo(trail[0].x, trail[0].y);
        for (let i = 1; i < trail.length; i++) {
            ctx.lineTo(trail[i].x, trail[i].y);
        }
        ctx.stroke();
        ctx.setLineDash([]);
    }

    // Draw Target
    ctx.fillStyle = "#00E676";
    ctx.beginPath();
    ctx.arc(target.x, target.y, 12, 0, Math.PI*2);
    ctx.fill();
    
    // Core of target
    ctx.fillStyle = "#fff";
    ctx.beginPath();
    ctx.arc(target.x, target.y, 4, 0, Math.PI*2);
    ctx.fill();
}

function loop() {
    update();
    draw();
    requestAnimationFrame(loop);
}

loop();
</script>
</body>
</html>